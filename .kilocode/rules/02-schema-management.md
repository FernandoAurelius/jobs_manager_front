# Schema and Type Management

## 🚨 ABSOLUTE RULE: NO LOCAL SCHEMAS FOR API DATA 🚨

### Unique Source of Truth: `src/api/generated/api.ts`

**ALL types and schemas related to API data MUST come ONLY from the autogenerated file [`src/api/generated/api.ts`].**

This file is generated by Zodios based on the backend's DRF-Spectacular OpenAPI schema. It is the ONLY source of truth for API types and schemas in the frontend. Never create or maintain parallel types, interfaces, or schemas for API data anywhere else in the codebase.

---

### Total Prohibition of Local Schemas

**NEVER create local TypeScript interfaces, types, or schemas that duplicate API functionality.**

---

### 🚨 DEFINITIVE TEST: DATABASE DATA PROHIBITION 🚨

**If this data is stored in the database, it is FORBIDDEN to model it in the frontend.**

This is the absolute, foolproof test to determine if a type should be created locally:

- **Database data** (jobs, staff, purchase orders, deliveries, timesheets, etc.) → ❌ FORBIDDEN
- **Form data for database entities** (contact forms, job, staff, etc.) → ❌ FORBIDDEN
- **API request/response types** (create requests, update requests, API responses) → ❌ FORBIDDEN
- **Pure UI structures ONLY** (dropdown options, tab names, filter structures, search forms) → ✅ ALLOWED

### Clarification: Form Data for Database Entities IS DATABASE DATA

If a form creates, updates, or represents data that will be stored in the database, it is DATABASE DATA and must use backend schemas. The only allowed frontend forms are pure UI constructs like search filters or display preferences that are never persisted.

---

### 🚨 WHEN IN DOUBT - DO NOT TOUCH THE CODE 🚨

**If there is ANY ambiguity about whether a type represents database data, DO NOT WRITE ANY CODE. DO NOT EDIT ANYTHING. STOP AND LEARN. NEVER TRY TO WORK AROUND THIS RESTRICTION.**

#### Prohibited Actions When in Doubt

- ❌ Create frontend types "just in case"
- ❌ Make assumptions about what the data represents
- ❌ Use words like "probably", "seems like"
- ❌ Modify working code based on assumptions

#### Correct Approach When in Doubt

- ✅ LEAVE THE CODE UNTOUCHED
- ✅ Document as Category C (missing backend schema)
- ✅ Only fix types when 100% certain they are pure UI constructs

---

### 🚨 NEVER COMMENT OUT OR DISABLE BROKEN IMPORTS 🚨

**DO NOT create temporary workarounds, placeholder types, or disable imports to "unblock" builds**

**If an import is broken due to missing backend schemas, LEAVE IT BROKEN and document the requirement**

**The build MUST fail until proper schemas exist - this maintains architectural integrity**

#### Prohibited Actions with Broken Imports

- ❌ Comment out imports
- ❌ Create placeholder types `any`
- ❌ Create temporary type definitions
- ❌ Use `// @ts-ignore` or similar suppressions
- ❌ "Unblock" builds with workarounds

#### Correct Approach

- ✅ Document missing schema requirement for the backend team
- ✅ Leave the import broken to maintain pressure for proper correction
- ✅ Focus on files that can be legitimately fixed

---

### Schema Generation and Update

```bash
# Update backend schemas
npm run update-schema

# Generate API types (this will update src/api/generated/api.ts)
npm run gen:api
```

---

### Backend Coordination

**If the generated schema is wrong:** Coordinate with the backend to add proper `@extend_schema` or `@extend_schema_field` annotations, then regenerate with `npm run update-schema`.

---

### Related references

- See: [01-architectural-separation.md](./01-architectural-separation.md)
- See: [05-api-integration.md](./05-api-integration.md)
- See: [13-backend-coordination.md](./13-backend-coordination.md)
